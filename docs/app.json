[{"name": "app.py", "content": "from shiny import App, render, ui\n\nfrom core.core_functions import (\n    load_base, \n    add_target_year, \n    set_last_doy, \n    calc_rank,\n    calc_cummean,\n)   \nfrom core.plot_functions import plot_main\n\napp_ui = ui.page_fluid(\n    ui.h2(\"tas to date\"),\n    ui.input_selectize(\n        id='region',\n        label='Region',\n        choices=[\n            'global',\n            'austria',\n            ],\n        selected='global',\n    ),\n    ui.input_selectize(\n        id='cumsum',\n        label='Aggregation',\n        choices=[\n            'T\u00e4glich',\n            'Mittelwert',\n        ],\n        selected='T\u00e4glich',\n    ),\n    ui.input_slider(\n        id='exceedance',\n        label='Extreme',\n        min=-1.1,\n        max=1.1,\n        value=1.1,\n        step=.1,        \n    ),\n    ui.input_slider(\n        id='year',\n        label='Jahr',\n        min=1950,\n        max=2021,\n        value=2021,\n        step=1,\n    ),\n    ui.input_slider(\n        id='last_doy',\n        label='Tag im Jahr',\n        min=1,\n        max=365,\n        value=150,\n        step=1,\n    ),\n    ui.output_plot(\n        id='plot',\n        width='1500px',\n        height='840px',\n        ),\n)\n\n\ndef server(input, output, session):\n\n    @output\n    @render.plot()\n    def plot():\n\n        ds = load_base(input.region())\n        add_target_year(ds, year=input.year())\n        ds = set_last_doy(ds, input.last_doy())\n        \n        if input.cumsum() == 'Mittelwert':\n            ds = calc_cummean(ds)\n        \n        ds = calc_rank(ds)\n        plot_main(ds, dpi_ratio=1.2, show_exceedance=input.exceedance())\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "app.py~", "content": "from shiny import App, render, ui\n\nfrom core.core_functions import load_plot_single\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hello Shiny!\"),\n    ui.input_selectize(\n        id='region',\n        label='Region',\n        choices=[\n            'global',\n            'austria',\n            ],\n        selected='global',\n    ),\n    ui.input_slider(\n        id='year',\n        label='Jahr',\n        min=1950,\n        max=2022,\n        value=2022,\n        step=1,\n    ),\n    ui.input_slider(\n        id='last_doy',\n        label='Tag im Jahr',\n        min=1,\n        max=365,\n        value=150,\n        step=1,\n    ),\n)\n\n\ndef server(input, output, session):\n\n    @output\n    @render.plot()\n    def plot():\n        load_plot_single(\n            region=input.region(),\n            year=input.year(),\n            last_doy=input.last_doy(),\n        )\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "main.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\n(c) by Lukas Brunner under a MIT License (https://mit-license.org)\n\nAuthors:\n- Lukas Brunner || lukas.brunner@env.ethz.ch\n\nAbstract:\n\n\"\"\"\nimport argparse\nfrom datetime import datetime\n\nfrom core.core_functions import combine_to_gif, load_plot_all, load_plot_single\nfrom core.utilities import regions\n\nparser = argparse.ArgumentParser(\n    description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter\n)\n\nparser.add_argument(\n    dest=\"year\",\n    nargs=\"?\",\n    default=datetime.now().year,\n    type=int,\n    help=\"Year to process (by defaults to current year)\",\n)\nparser.add_argument(\n    \"--regions\",\n    \"-r\",\n    dest=\"regions\",\n    nargs=\"+\",\n    default=regions,\n    type=str,\n    help=\"Regions to process (by default all available regions)\",\n)\nparser.add_argument(\n    \"--day-of-year\",\n    \"-doy\",\n    dest=\"doy\",\n    type=int,\n    default=None,\n    choices=range(1, 366),\n    help=\"Only plot given day of the year and save in temp directory\"\n)\nparser.add_argument(\n    \"--language\",\n    \"-l\",\n    dest=\"language\",\n    type=str,\n    default=\"german\",\n    choices=[\"german\", \"english\"],\n    help=\"Select language of plot labels\",\n)\nparser.add_argument(\n    \"--overwrite\",\n    \"-o\",\n    dest=\"overwrite\",\n    action=\"store_true\",\n    help=\"Overwrite existing plot files\",\n)\nparser.add_argument(\n    \"--show-exceedance\",\n    \"-e\",\n    dest=\"show_exceedance\",\n    type=float,\n    default=1,\n    help=\"If in [-1, 1] show exeedances of given quantile (see docstring for interpretation of negative values)\",\n)\nargs = parser.parse_args()\n\nyear = args.year\nprint(f\"{year=}\")\n\nfor region in args.regions:\n    print(\"\")\n    print(f\"{region=}\")\n    print(\"-\" * 20)\n\n    if args.doy is None:\n        fn_daily, fn_cummean, fn_both = load_plot_all(\n            region=region,\n            year=year,\n            overwrite=args.overwrite,\n            language=args.language,\n            show_exceedance=args.show_exceedance,\n        )\n\n        combine_to_gif(fn_daily, stepsize=1, delay=10)\n        combine_to_gif(fn_cummean, stepsize=1, delay=10)\n        combine_to_gif(fn_both, stepsize=1, delay=10)\n\n    else:\n        load_plot_single(\n            region=region,\n            year=year,\n            last_doy=args.doy,\n            show_exceedance=args.show_exceedance\n        )\n", "type": "text"}, {"name": "core/__init__.py", "content": "", "type": "text"}, {"name": "core/core_functions.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\n(c) by Lukas Brunner under a MIT License (https://mit-license.org)\n\nAuthors:\n- Lukas Brunner || lukas.brunner@env.ethz.ch\n\nAbstract: Main functions for calculating time-series of cumulative\ntemperature in different regions.\n\"\"\"\nimport os\nfrom glob import glob\nfrom typing import List\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\n\nfrom .plot_functions import plot_main\nfrom .utilities import average_region, kelvin_to_centigrade, time_to_dayofyear\n\nmpl.rc(\"font\", size=20)\nplt.rcParams.update(\n    {\"text.usetex\": True, \"font.family\": \"sans-serif\", \"font.sans-serif\": [\"Helvetica\"]}\n)\n\ncurrent_path = os.path.dirname(os.path.abspath(__file__))\nload_path = \"/scratch/shared/ERA5/\"\nplot_path = os.path.join(current_path, \"../../figures\")\ndata_path = os.path.join(current_path, \"../../data\")\nfn_pattern = \"tas_preprocessed_{region}.nc\"\n\n\ndef preprocess_region(region: str, overwrite: bool = False) -> xr.Dataset:\n    \"\"\"Preprocess data to speed up further processing.\n\n    - Rename spatial dimensions\n    - cut and average region\n    - convert time to year and day of the year\n    - convert Kelvin to Centigrade\n    - add some metadata\n    \"\"\"\n    fn_save = os.path.join(data_path, fn_pattern.format(region=region))\n    if not overwrite and os.path.isfile(fn_save):\n        return\n\n    path_era5 = os.path.join(load_path, \"ERA5/2m_temperature/day/native/*.nc\")\n    path_era5_prelimbe = os.path.join(\n        load_path, \"ERA5_prelimbe/2m_temperature/day/native/*.nc\"\n    )\n    filenames = glob(path_era5_prelimbe) + glob(path_era5)\n\n    da_list = []\n    for fn in filenames:\n        year = int(fn.split(\"_\")[-2])\n        da = xr.open_dataset(fn, use_cftime=True)[\"t2m\"]\n        da = da.rename({\"longitude\": \"lon\", \"latitude\": \"lat\"})\n        da = average_region(da, region)\n        da = time_to_dayofyear(da)\n        da = da.expand_dims({\"year\": [year]})\n        da = kelvin_to_centigrade(da)\n        da_list.append(da)\n    da = xr.concat(da_list, dim=\"year\")\n\n    # set some metadata\n    da.attrs[\"long_name\"] = \"Near Surface Air Temperature\"\n    da.attrs[\"original_files\"] = \", \".join(filenames)\n    ds = da.to_dataset(name=\"tas_base\")\n    ds.attrs[\"region\"] = region\n\n    ds.to_netcdf(fn_save)\n\n\ndef load_base(region: str) -> xr.Dataset:\n    \"\"\"Load data saved by preprocess_region.\"\"\"\n    fn = os.path.join(data_path, fn_pattern.format(region=region))\n    ds = xr.open_dataset(fn, use_cftime=True)\n    return ds\n\n\ndef load_year_current(year: int, region: str) -> xr.DataArray:\n    \"\"\"Separately load if year is current (i.e., not preprocessed).\"\"\"\n    path = os.path.join(load_path, f\"ERA5_nrt/2m_temperature/day/native/*_{year}_daily.nc\")\n    filenames = glob(path)\n    da = xr.open_mfdataset(filenames, use_cftime=True)[\"t2m\"]\n    da = da.rename({\"longitude\": \"lon\", \"latitude\": \"lat\"})\n    da = average_region(da, region)\n    da = time_to_dayofyear(da)\n    da = kelvin_to_centigrade(da)\n    da.attrs[\"long_name\"] = \"Near Surface Air Temperature\"\n    da.attrs[\"original_files\"] = \", \".join(filenames)\n    return da\n\n\ndef add_target_year(ds_base: xr.Dataset, year: int,) -> xr.Dataset:\n    \"\"\"Extract of load target year and add it as separate variable.\"\"\"\n    try:\n        da = ds_base.sel(year=year, drop=True)[\"tas_base\"]\n        doy = 365\n    except KeyError:\n        da = load_year_current(year, ds_base.attrs[\"region\"])\n        # TODO: I think doy is always just index+1 right?\n        doy = da[\"dayofyear\"].values[np.where(np.isfinite(da.values))[0][-1]]\n\n    da.name = \"tas\"\n    ds_base.attrs[\"year\"] = year\n    ds_base.attrs[\"last_doy\"] = doy\n    ds_base[\"tas\"] = da\n\n\ndef calc_rank(ds: xr.Dataset) -> xr.Dataset:\n    \"\"\"Calculate the rank of the target year and add it as variable.\"\"\"\n    ds.load()\n    year = ds.attrs[\"year\"]\n    if year > ds[\"year\"].values[-1]:  # out of sample need to add it first\n        da = ds[\"tas\"].expand_dims({\"year\": [ds.attrs[\"year\"]]})\n        da = xr.concat([ds[\"tas_base\"], da], dim=\"year\")\n    else:\n        da = ds[\"tas_base\"]\n    # double argsort to get the rank then inverse (highest first)\n    rank = da[\"year\"].size - np.argsort(np.argsort(da, axis=0), axis=0)\n    rank.name = \"rank\"\n    return xr.merge([ds, rank])\n\n\ndef calc_cummean(ds: xr.Dataset) -> xr.Dataset:\n    \"\"\"Calculate the cummulative mean since the beginning of the year.\"\"\"\n    attrs = ds.attrs\n    ds = ds.cumsum(\"dayofyear\") / ds[\"dayofyear\"]\n    ds = set_last_doy(ds, attrs[\"last_doy\"])\n    ds.attrs = attrs\n    ds.attrs[\"cummean\"] = \"True\"\n    return ds\n\n\ndef set_last_doy(ds: xr.Dataset, doy: int) -> xr.Dataset:\n    \"\"\"Manually set until which day of the year the target runs.\"\"\"\n    ds = ds.copy()\n    ds[\"tas\"] = ds[\"tas\"].where(ds[\"dayofyear\"] <= doy)\n    ds[\"tas\"].astype(np.float)\n    ds.attrs[\"last_doy\"] = doy\n    return ds\n\n\ndef get_filename(ds: xr.Dataset, cummean: str, ext: str = \".jpg\", tmp_dir: bool=False) -> str:\n    region = ds.attrs[\"region\"]\n    year = str(ds.attrs[\"year\"])\n    doy = \"{:03d}\".format(ds.attrs[\"last_doy\"])\n    if tmp_dir:\n        path = os.path.join(plot_path, 'tmp')\n    else:\n        path = os.path.join(plot_path, region, year, cummean)\n    os.makedirs(path, exist_ok=True)\n    fn = \"_\".join([\"tas\", cummean, region, year, doy])\n    return os.path.join(path, fn + ext)\n\n\ndef load_plot_single(\n    region: str,\n    year: int,\n    last_doy: int = None,\n    dpi_ratio: float = 1.2,\n    save: bool = True,\n    save_format: str = \".jpg\",\n    show_exceedance: float = 1.1,\n):\n    \"\"\"Like load_plot_all but only for one day. See there for docstring.\"\"\"\n    ds = load_base(region)\n    add_target_year(ds, year=year)\n    ds_cum = calc_cummean(ds)\n    ds = calc_rank(ds)\n    ds_cum = calc_rank(ds_cum)\n\n    if last_doy is not None:\n        ds = set_last_doy(ds, last_doy)\n        ds_cum = set_last_doy(ds_cum, last_doy)\n\n    plot_main(ds, dpi_ratio=dpi_ratio, show_exceedance=show_exceedance)\n    if save:\n        fn = get_filename(ds, \"daily\", \"\", tmp_dir=True)\n        plt.savefig(fn + save_format, dpi=72)\n        # try:\n        #     os.remove(fn)\n        #     sleep(1)\n        # except FileNotFoundError:\n        #     pass\n        ds.to_netcdf(fn + \".nc\")\n    plt.show()\n    plt.close()\n\n    plot_main(ds_cum, dpi_ratio=dpi_ratio, show_exceedance=show_exceedance)\n    if save:\n        fn = get_filename(ds_cum, \"cummean\", \"\", tmp_dir=True)\n        plt.savefig(fn + save_format, dpi=72)\n        ds_cum.to_netcdf(fn + \".nc\")\n    plt.show()\n    plt.close()\n\n    # fig, (ax1, ax2) = plt.subplots(\n    #     2, figsize=(16/dpi_ratio, 18/dpi_ratio), dpi=75*dpi_ratio)\n    # plot_main(ds, ax=ax1)\n    # plot_main(ds_cum, ax=ax2)\n    # if save:\n    #     fn = get_filename(ds, 'both')\n    #     plt.savefig(fn + save_format, dpi=72)\n    # plt.show()\n    # plt.close()\n\n    return ds, ds_cum\n\n\ndef load_plot_all(\n    region: str,\n    year: int,\n    dpi_ratio: float = 1.2,\n    save_format: str = \".jpg\",\n    overwrite=False,\n    produce_gif=True,\n    language=\"german\",\n    show_exceedance: float = 1.1,\n) -> List[str]:\n    \"\"\"Main function. Loops over all possible days.\n\n    - load data\n    - plot data\n    - save plots\n    - save data\n    - procude gif (optional)\n    \"\"\"\n    ds = load_base(region)\n    add_target_year(ds, year=year)\n    ds_cum = calc_cummean(ds)\n    ds = calc_rank(ds)\n    ds_cum = calc_rank(ds_cum)\n\n    last_doy = ds.attrs[\"last_doy\"]\n    for doy in range(1, last_doy + 1):\n        print_nr = 10\n        print_denom = last_doy // print_nr + 1\n        if doy % print_denom == 0 or doy == last_doy:\n            print(f\"Processing day of year: {doy}\")\n        ds_sel = set_last_doy(ds, doy)\n        ds_cum_sel = set_last_doy(ds_cum, doy)\n\n        fn = get_filename(ds_sel, \"daily\", save_format)\n        if overwrite or not os.path.isfile(fn):\n            plot_main(ds_sel, dpi_ratio=dpi_ratio, language=language, show_exceedance=show_exceedance)\n            plt.savefig(fn, dpi=150)\n            plt.close()\n\n        fn = get_filename(ds_cum_sel, \"cummean\", save_format)\n        if overwrite or not os.path.isfile(fn):\n            plot_main(ds_cum_sel, dpi_ratio=dpi_ratio, language=language, show_exceedance=1.1)\n            plt.savefig(fn, dpi=150)\n            plt.close()\n\n        fn = get_filename(ds_sel, \"both\", save_format)\n        if overwrite or not os.path.isfile(fn):\n            fig, (ax1, ax2) = plt.subplots(\n                2, figsize=(16 / dpi_ratio, 18 / dpi_ratio), dpi=75 * dpi_ratio\n            )\n            plot_main(ds_sel, ax=ax1, language=language, show_exceedance=show_exceedance)\n            plot_main(ds_cum_sel, ax=ax2, language=language, show_exceedance=1.1)\n            plt.savefig(fn, dpi=150)\n            plt.close()\n\n    fn = get_filename(ds, \"daily\", \".nc\")\n    if overwrite or not os.path.isfile(fn):\n        # try:\n        #     os.remove(fn)\n        #     sleep(1)\n        # except FileNotFoundError:\n        #     pass\n        ds.to_netcdf(fn)\n    fn = get_filename(ds_cum, \"cummean\", \".nc\")\n    if overwrite or not os.path.isfile(fn):\n        # try:\n        #     os.remove(fn)\n        #     sleep(1)\n        # except FileNotFoundError:\n        #     pass\n        ds_cum.to_netcdf(fn)\n\n    if produce_gif:\n        combine_to_gif(get_filename(ds, \"daily\", save_format), overwrite=overwrite)\n        combine_to_gif(\n            get_filename(ds_cum, \"cummean\", save_format), overwrite=overwrite\n        )\n        combine_to_gif(get_filename(ds, \"both\", save_format), overwrite=overwrite)\n\n    return (\n        get_filename(ds, \"daily\", save_format),\n        get_filename(ds_cum, \"cummean\", save_format),\n        get_filename(ds, \"both\", save_format),\n    )\n\n\ndef combine_to_gif(\n    fn: str,\n    stepsize: int = \"auto\",\n    delay: int = 40,\n    resize: int = 1000,\n    overwrite=False,\n):\n    \"\"\"Combine individual figures to gif.\n\n    Parameters\n    ----------\n    fn : str\n        full path (path + filename + extension) of ONE figure (will determine\n        gif filename)\n    stepsize : int, by default 'auto'\n        If auto the stepsize will be chosen so that the gif has max 100 steps.\n        Set to 1 to include all figures (might result in large file sizes).\n    delay : int, by default 10\n        See convert -h delay\n    resize : int, by default 640\n        See convert -h resize\n    \"\"\"\n    path, fn = os.path.split(fn)\n    fn, ext = os.path.splitext(fn)\n    path_parent = \"/\".join(path.split(\"/\")[:-1])\n    fn += f\"_stepsize-{stepsize}_delay-{delay}_size-{resize}\"\n    fn = os.path.join(path_parent, fn + \".gif\")\n\n    filenames = glob(os.path.join(path, f\"*{ext}\"))\n    if stepsize == \"auto\":\n        stepsize = len(filenames) // 180 + 1\n    filenames = \" \".join(filenames[::stepsize])\n\n    if overwrite or not os.path.isfile(fn):\n        os.system(f\"convert -delay {delay} -resize {resize} {filenames} {fn}\")\n", "type": "text"}, {"name": "core/core_functions.py~", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\n(c) by Lukas Brunner under a MIT License (https://mit-license.org)\n\nAuthors:\n- Lukas Brunner || lukas.brunner@env.ethz.ch\n\nAbstract: Main functions for calculating time-series of cumulative\ntemperature in different regions.\n\"\"\"\nimport os\nfrom glob import glob\nfrom typing import List\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\n\nfrom .plot_functions import plot_main\nfrom .utilities import average_region, kelvin_to_centigrade, time_to_dayofyear\n\nmpl.rc(\"font\", size=20)\nplt.rcParams.update(\n    {\"text.usetex\": True, \"font.family\": \"sans-serif\", \"font.sans-serif\": [\"Helvetica\"]}\n)\n\ncurrent_path = os.path.dirname(os.path.abspath(__file__))\nload_path = \"/scratch/shared/ERA5/\"\nplot_path = os.path.join(current_path, \"../../figures\")\ndata_path = os.path.join(current_path, \"../../data\")\nfn_pattern = \"tas_preprocessed_{region}.nc\"\n\n\ndef preprocess_region(region: str, overwrite: bool = False) -> xr.Dataset:\n    \"\"\"Preprocess data to speed up further processing.\n\n    - Rename spatial dimensions\n    - cut and average region\n    - convert time to year and day of the year\n    - convert Kelvin to Centigrade\n    - add some metadata\n    \"\"\"\n    fn_save = os.path.join(data_path, fn_pattern.format(region=region))\n    if not overwrite and os.path.isfile(fn_save):\n        return\n\n    path_era5 = os.path.join(load_path, \"ERA5/2m_temperature/day/native/*.nc\")\n    path_era5_prelimbe = os.path.join(\n        load_path, \"ERA5_prelimbe/2m_temperature/day/native/*.nc\"\n    )\n    filenames = glob(path_era5_prelimbe) + glob(path_era5)\n\n    da_list = []\n    for fn in filenames:\n        year = int(fn.split(\"_\")[-2])\n        da = xr.open_dataset(fn, use_cftime=True)[\"t2m\"]\n        da = da.rename({\"longitude\": \"lon\", \"latitude\": \"lat\"})\n        da = average_region(da, region)\n        da = time_to_dayofyear(da)\n        da = da.expand_dims({\"year\": [year]})\n        da = kelvin_to_centigrade(da)\n        da_list.append(da)\n    da = xr.concat(da_list, dim=\"year\")\n\n    # set some metadata\n    da.attrs[\"long_name\"] = \"Near Surface Air Temperature\"\n    da.attrs[\"original_files\"] = \", \".join(filenames)\n    ds = da.to_dataset(name=\"tas_base\")\n    ds.attrs[\"region\"] = region\n\n    ds.to_netcdf(fn_save)\n\n\ndef load_base(region: str) -> xr.Dataset:\n    \"\"\"Load data saved by preprocess_region.\"\"\"\n    fn = os.path.join(data_path, fn_pattern.format(region=region))\n    ds = xr.open_dataset(fn, use_cftime=True)\n    return ds\n\n\ndef load_year_current(region: str) -> xr.DataArray:\n    \"\"\"Separately load if year is current (i.e., not preprocessed).\"\"\"\n    path = os.path.join(load_path, \"ERA5_nrt/2m_temperature/day/native/*.nc\")\n    filenames = glob(path)\n    da = xr.open_mfdataset(filenames, use_cftime=True)[\"t2m\"]\n    da = da.rename({\"longitude\": \"lon\", \"latitude\": \"lat\"})\n    da = average_region(da, region)\n    da = time_to_dayofyear(da)\n    da = kelvin_to_centigrade(da)\n    da.attrs[\"long_name\"] = \"Near Surface Air Temperature\"\n    da.attrs[\"original_files\"] = \", \".join(filenames)\n    return da\n\n\ndef add_target_year(ds_base: xr.Dataset, year: int,) -> xr.Dataset:\n    \"\"\"Extract of load target year and add it as separate variable.\"\"\"\n    try:\n        da = ds_base.sel(year=year, drop=True)[\"tas_base\"]\n        doy = 365\n    except KeyError:\n        da = load_year_current(ds_base.attrs[\"region\"])\n        # TODO: I think doy is always just index+1 right?\n        doy = da[\"dayofyear\"].values[np.where(np.isfinite(da.values))[0][-1]]\n\n    da.name = \"tas\"\n    ds_base.attrs[\"year\"] = year\n    ds_base.attrs[\"last_doy\"] = doy\n    ds_base[\"tas\"] = da\n\n\ndef calc_rank(ds: xr.Dataset) -> xr.Dataset:\n    \"\"\"Calculate the rank of the target year and add it as variable.\"\"\"\n    ds.load()\n    year = ds.attrs[\"year\"]\n    if year > ds[\"year\"].values[-1]:  # out of sample need to add it first\n        da = ds[\"tas\"].expand_dims({\"year\": [ds.attrs[\"year\"]]})\n        da = xr.concat([ds[\"tas_base\"], da], dim=\"year\")\n    else:\n        da = ds[\"tas_base\"]\n    # double argsort to get the rank then inverse (highest first)\n    rank = da[\"year\"].size - np.argsort(np.argsort(da, axis=0), axis=0)\n    rank.name = \"rank\"\n    return xr.merge([ds, rank])\n\n\ndef calc_cummean(ds: xr.Dataset) -> xr.Dataset:\n    \"\"\"Calculate the cummulative mean since the beginning of the year.\"\"\"\n    attrs = ds.attrs\n    ds = ds.cumsum(\"dayofyear\") / ds[\"dayofyear\"]\n    ds = set_last_doy(ds, attrs[\"last_doy\"])\n    ds.attrs = attrs\n    ds.attrs[\"cummean\"] = \"True\"\n    return ds\n\n\ndef set_last_doy(ds: xr.Dataset, doy: int) -> xr.Dataset:\n    \"\"\"Manually set until which day of the year the target runs.\"\"\"\n    ds = ds.copy()\n    ds[\"tas\"] = ds[\"tas\"].where(ds[\"dayofyear\"] <= doy)\n    ds[\"tas\"].astype(np.float)\n    ds.attrs[\"last_doy\"] = doy\n    return ds\n\n\ndef get_filename(ds: xr.Dataset, cummean: str, ext: str = \".jpg\") -> str:\n    region = ds.attrs[\"region\"]\n    year = str(ds.attrs[\"year\"])\n    doy = \"{:03d}\".format(ds.attrs[\"last_doy\"])\n    path = os.path.join(plot_path, region, year, cummean)\n    os.makedirs(path, exist_ok=True)\n    fn = \"_\".join([\"tas\", cummean, region, year, doy])\n    return os.path.join(path, fn + ext)\n\n\ndef load_plot_single(\n    region: str,\n    year: int,\n    last_doy: int = None,\n    dpi_ratio: float = 1.2,\n    save: bool = False,\n    save_format: str = \".jpg\",\n    show_exceedance: float = 1.1,\n):\n    \"\"\"Like load_plot_all but only for one day. See there for docstring.\"\"\"\n    ds = load_base(region)\n    add_target_year(ds, year=year)\n\n    if last_doy is not None:\n        ds = set_last_doy(ds, last_doy)\n\n    ds_cum = calc_cummean(ds)\n    ds = calc_rank(ds)\n    ds_cum = calc_rank(ds_cum)\n    breakpoint()\n\n    plot_main(ds, dpi_ratio=dpi_ratio, show_exceedance=show_exceedance)\n    if save:\n        fn = get_filename(ds, \"daily\", \"\")\n        plt.savefig(fn + save_format, dpi=72)\n        # try:\n        #     os.remove(fn)\n        #     sleep(1)\n        # except FileNotFoundError:\n        #     pass\n        ds.to_netcdf(fn + \".nc\")\n    plt.show()\n    plt.close()\n\n    plot_main(ds_cum, dpi_ratio=dpi_ratio, show_exceedance=show_exceedance)\n    if save:\n        fn = get_filename(ds_cum, \"cummean\", \"\")\n        plt.savefig(fn + save_format, dpi=72)\n        ds_cum.to_netcdf(fn + \".nc\")\n    plt.show()\n    plt.close()\n\n    # fig, (ax1, ax2) = plt.subplots(\n    #     2, figsize=(16/dpi_ratio, 18/dpi_ratio), dpi=75*dpi_ratio)\n    # plot_main(ds, ax=ax1)\n    # plot_main(ds_cum, ax=ax2)\n    # if save:\n    #     fn = get_filename(ds, 'both')\n    #     plt.savefig(fn + save_format, dpi=72)\n    # plt.show()\n    # plt.close()\n\n    return ds, ds_cum\n\n\ndef load_plot_all(\n    region: str,\n    year: int,\n    dpi_ratio: float = 1.2,\n    save_format: str = \".jpg\",\n    overwrite=False,\n    produce_gif=True,\n    language=\"german\",\n    show_exceedance: float = 1.1,\n) -> List[str]:\n    \"\"\"Main function. Loops over all possible days.\n\n    - load data\n    - plot data\n    - save plots\n    - save data\n    - procude gif (optional)\n    \"\"\"\n    ds = load_base(region)\n    add_target_year(ds, year=year)\n    ds_cum = calc_cummean(ds)\n    ds = calc_rank(ds)\n    ds_cum = calc_rank(ds_cum)\n\n    last_doy = ds.attrs[\"last_doy\"]\n    for doy in range(1, last_doy + 1):\n        print_nr = 10\n        print_denom = last_doy // print_nr + 1\n        if doy % print_denom == 0:\n            print(f\"Processing day of year: {doy}\")\n        ds_sel = set_last_doy(ds, doy)\n        ds_cum_sel = set_last_doy(ds_cum, doy)\n\n        fn = get_filename(ds_sel, \"daily\", save_format)\n        if overwrite or not os.path.isfile(fn):\n            plot_main(ds_sel, dpi_ratio=dpi_ratio, language=language, show_exceedance=show_exceedance)\n            plt.savefig(fn, dpi=150)\n            plt.close()\n\n        fn = get_filename(ds_cum_sel, \"cummean\", save_format)\n        if overwrite or not os.path.isfile(fn):\n            plot_main(ds_cum_sel, dpi_ratio=dpi_ratio, language=language, show_exceedance=show_exceedance)\n            plt.savefig(fn, dpi=150)\n            plt.close()\n\n        fn = get_filename(ds_sel, \"both\", save_format)\n        if overwrite or not os.path.isfile(fn):\n            fig, (ax1, ax2) = plt.subplots(\n                2, figsize=(16 / dpi_ratio, 18 / dpi_ratio), dpi=75 * dpi_ratio\n            )\n            plot_main(ds_sel, ax=ax1, language=language, show_exceedance=show_exceedance)\n            plot_main(ds_cum_sel, ax=ax2, language=language, show_exceedance=show_exceedance)\n            plt.savefig(fn, dpi=150)\n            plt.close()\n\n    fn = get_filename(ds, \"daily\", \".nc\")\n    if overwrite or not os.path.isfile(fn):\n        # try:\n        #     os.remove(fn)\n        #     sleep(1)\n        # except FileNotFoundError:\n        #     pass\n        ds.to_netcdf(fn)\n    fn = get_filename(ds_cum, \"cummean\", \".nc\")\n    if overwrite or not os.path.isfile(fn):\n        # try:\n        #     os.remove(fn)\n        #     sleep(1)\n        # except FileNotFoundError:\n        #     pass\n        ds_cum.to_netcdf(fn)\n\n    if produce_gif:\n        combine_to_gif(get_filename(ds, \"daily\", save_format), overwrite=overwrite)\n        combine_to_gif(\n            get_filename(ds_cum, \"cummean\", save_format), overwrite=overwrite\n        )\n        combine_to_gif(get_filename(ds, \"both\", save_format), overwrite=overwrite)\n\n    return (\n        get_filename(ds, \"daily\", save_format),\n        get_filename(ds_cum, \"cummean\", save_format),\n        get_filename(ds, \"both\", save_format),\n    )\n\n\ndef combine_to_gif(\n    fn: str,\n    stepsize: int = \"auto\",\n    delay: int = 40,\n    resize: int = 1000,\n    overwrite=False,\n):\n    \"\"\"Combine individual figures to gif.\n\n    Parameters\n    ----------\n    fn : str\n        full path (path + filename + extension) of ONE figure (will determine\n        gif filename)\n    stepsize : int, by default 'auto'\n        If auto the stepsize will be chosen so that the gif has max 100 steps.\n        Set to 1 to include all figures (might result in large file sizes).\n    delay : int, by default 10\n        See convert -h delay\n    resize : int, by default 640\n        See convert -h resize\n    \"\"\"\n    path, fn = os.path.split(fn)\n    fn, ext = os.path.splitext(fn)\n    path_parent = \"/\".join(path.split(\"/\")[:-1])\n    fn += f\"_stepsize-{stepsize}_delay-{delay}_size-{resize}\"\n    fn = os.path.join(path_parent, fn + \".gif\")\n\n    filenames = glob(os.path.join(path, f\"*{ext}\"))\n    if stepsize == \"auto\":\n        stepsize = len(filenames) // 180 + 1\n    filenames = \" \".join(filenames[::stepsize])\n\n    if overwrite or not os.path.isfile(fn):\n        os.system(f\"convert -delay {delay} -resize {resize} {filenames} {fn}\")\n", "type": "text"}, {"name": "core/plot_functions.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\n(c) by Lukas Brunner under a MIT License (https://mit-license.org)\n\nAuthors:\n- Lukas Brunner || lukas.brunner@env.ethz.ch\n\nAbstract: A collection of plotting functions.\n\"\"\"\nimport os\nfrom datetime import datetime\nfrom typing import List, Tuple\n\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\nfrom matplotlib.offsetbox import AnnotationBbox, OffsetImage\n\nmap_names = {\n    \"global\": \"Global\",\n    \"global-land\": \"Global (Land)\",\n    \"europe-land\": \"in Europa (Land)\",\n    \"europe\": \"in Europa\",\n    \"wce-land\": \"in Zentraleuropa\",\n    \"austria\": \"in \u00d6sterreich\",\n}\n\nmap_names_en = {\n    \"global\": \"global\",\n    \"global-land\": \"global (land)\",\n    \"europe-land\": \"in Europe (land)\",\n    \"europe\": \"in Europe\",\n    \"wce-land\": \"in Central Europe\",\n    \"austria\": \"in Austria\",\n}\n\ncurrent_path = os.path.dirname(os.path.abspath(__file__))\n\n\ndef plot_base(\n    ax: plt.Axes,\n    ds: xr.DataArray,\n    mean: bool = False,\n    median: bool = True,\n    q_ranges: List[Tuple[float, float]] = [\n        (0.0, 1.0),\n        (0.1, 0.9),\n        (0.2, 0.8),\n        (0.3, 0.7),\n        (0.4, 0.6),\n    ],\n    record: bool = True,\n    german: bool = True,\n    annotate: bool = True,\n) -> tuple:\n    \"\"\"Plot background shading and basic axis.\"\"\"\n    if mean and median:\n        raise ValueError('Only one of \"median\" and \"mean\" can be True')\n\n    cummean = bool(ds.attrs.get(\"cummean\", False))\n    year = ds.attrs[\"year\"]\n    region = ds.attrs[\"region\"]\n    last_doy = ds.attrs[\"last_doy\"]\n    doys = ds[\"dayofyear\"].values\n\n    for q1, q2 in q_ranges:\n        hh = ax.fill_between(\n            doys,\n            ds[\"tas_base\"].quantile(q1, \"year\"),\n            ds[\"tas_base\"].quantile(q2, \"year\"),\n            facecolor=\"k\",\n            edgecolor=\"none\",\n            alpha=0.1,\n        )\n\n    if mean:\n        [h2] = ax.plot(doys, ds[\"tas_base\"].mean(\"year\"), color=\"k\", lw=0.5)\n        hh = (hh, h2)\n    if median:\n        [h2] = ax.plot(doys, ds[\"tas_base\"].median(\"year\"), color=\"k\", lw=0.5)\n        hh = (hh, h2)\n\n    ax.set_xlim(doys[0], doys[-1])\n    ax.set_xticks([1, 60, 121, 182, 243, 304, 365])\n    ax.set_yticks(ax.get_yticks())\n    ax.set_yticklabels(\n        [int(ll) if float(ll).is_integer() else ll for ll in ax.get_yticks()]\n    )\n    ax.yaxis.set_ticks_position(\"both\")\n    if german:\n        ax.set_ylabel(\"Temperatur ($^\\\\circ$C)\")\n        ax.set_xticklabels(\n            [\"1. J\u00e4n.\", \"1. M\u00e4rz\", \"1. Mai\", \"1. Jul.\", \"1. Sep\", \"1. Nov.\", \"31. Dez.\"]\n        )\n        if year is not None and last_doy is not None and region is not None:\n            date = datetime.strptime(f\"{year}-{last_doy}\", \"%Y-%j\").strftime(\"%d.%m.%Y\")\n            if cummean:\n                ax.set_title(\n                    \"Kumulative Mitteltemperatur {} bis {}\".format(\n                        map_names[region], date\n                    )\n                )\n            else:\n                ax.set_title(\n                    \"Tagesmitteltemperatur {} bis {}\".format(map_names[region], date)\n                )\n        if cummean:\n            ax.text(\n                0.99,\n                0.4,\n                \"\\n\".join(\n                    [\n                        \"\\\\textbf{Kumulative Mitteltemperatur}\",\n                        \"Mittlere Temperatur vom 1. J\u00e4nnner\",\n                        \"bis zum angegebenen Tag\",\n                    ]\n                ),\n                ha=\"right\",\n                va=\"top\",\n                fontsize=\"small\",\n                transform=ax.transAxes,\n            )\n    else:\n        ax.set_ylabel(\"Temperature ($^\\\\circ$C)\")\n        ax.set_xticklabels(\n            [\"1. Jan.\", \"1. Mar.\", \"1. May\", \"1. Jul.\", \"1. Sep\", \"1. Nov.\", \"31. Dec.\"]\n        )\n        if year is not None and last_doy is not None and region is not None:\n            date = datetime.strptime(f\"{year}-{last_doy}\", \"%Y-%j\").strftime(\"%d.%m.%Y\")\n            if cummean:\n                ax.set_title(\n                    \"Cumulative mean temperature {} to {}\".format(\n                        map_names_en[region], date\n                    )\n                )\n            else:\n                ax.set_title(\n                    \"Daily mean temperature {} to {}\".format(map_names_en[region], date)\n                )\n        if cummean:\n            ax.text(\n                0.99,\n                0.4,\n                \"\\n\".join(\n                    [\n                        \"\\\\textbf{Cumulative mean temperature}\",\n                        \"Mean temperature from January 1$^\\\\textnormal{st}$\",\n                        \"until the indicated day\",\n                    ]\n                ),\n                ha=\"right\",\n                va=\"top\",\n                fontsize=\"small\",\n                transform=ax.transAxes,\n            )\n    if annotate:\n        annotate_shading(ax, ds[\"tas_base\"], german)\n\n    return hh\n\n\ndef plot_target(\n    ax: plt.Axes,\n    ds: xr.Dataset,\n    show_record: Tuple[bool, str] = \"always\",\n    show_exceedance: float = 1.,\n    show_rank: bool = True,\n) -> \"handle\":\n    \"\"\"Plot the target year and related information.\n\n    Parameters\n    ----------\n    ax : plt.Axes\n    ds : xr.Dataset\n    show_record : bool or 'always', optional, by default 'always'\n        If False do not show days with a new record. If True only show the\n        indicator if there is at least one day with a record. If 'always'\n        always show it. TODO: remove - redundant with 'show_exceedance'\n    show_exceedance : float, optional, by default 1.\n        Several cases are disdinguished:\n          - if absolute value larger than 1 do not show days with exceedances or new records\n          - if exactly 1 show new heat records (default)\n          - if exactly -1 show new cold records\n          - if positive show exceedances of the given quantile\n          - if negative show undercuts of given (absolut value) of quantile\n    show_rank : bool, optional, by default True\n        Annotate the last day with rank and anomaly.\n\n    Returns\n    -------\n    handle\n        For use in the figure legend.\n    \"\"\"\n    [h2] = ax.plot(ds[\"dayofyear\"], ds[\"tas\"], color=\"darkred\")\n    # if show_record is not None:\n    #     mark_record(ax, ds, show_record == \"always\")\n    if np.abs(show_exceedance) <= 1:\n            mark_exceedance(ax, ds, show_exceedance)\n    if show_rank:\n        annotate_last_day(ax, ds)\n    return h2\n\n\ndef mark_record(ax: plt.Axes, ds: xr.Dataset, always: bool = False) -> None:\n    \"\"\"Indicate days where the year has the maximum value.\"\"\"\n    max_ = ds[\"tas\"] >= ds[\"tas_base\"].max(\"year\")\n    # min_ = ds[\"tas\"] <= ds[\"tas_base\"].min(\"year\")\n    # record = np.logical_or(max_, min_)\n    y_min = ds[\"tas_base\"].min()  # for line placement\n    if np.any(max_) or always:\n        max_ = (max_.where(max_) * 0) + y_min\n        ax.axhline(y_min, color=\"k\", ls=\"--\", lw=0.5)\n        ax.text(\n            33,\n            y_min,\n            \"Tage mit Hitzerekord: {}/{}\".format(\n                np.isfinite(max_).sum().values, np.isfinite(ds[\"tas\"]).sum().values\n            ),\n            va=\"bottom\",\n        )\n        ax.plot(ds[\"dayofyear\"], max_, marker=\"s\", ms=2, ls=\"none\", color=\"darkred\")\n        ds.attrs[\"show_record\"] = \"True\"\n\n\ndef mark_exceedance(ax: plt.Axes, ds: xr.Dataset, quantile: float, always: bool = True) -> None:\n    \"\"\"Indicate days where the year exceeds a given percentile.\"\"\"\n    year = ds.attrs[\"year\"]\n    # remove year itself (otherwise there will be no new records for in-sample)\n    ds = ds.sel(year=ds[\"year\"] != year)\n\n    if quantile == 1:\n        threshold = ds[\"tas\"] >= ds[\"tas_base\"].max(\"year\")\n        text = \"Tage mit Hitzerekord\"\n    elif quantile == -1:\n        threshold = ds[\"tas\"] <= ds[\"tas_base\"].min(\"year\")\n        text = \"Tage mit K\u00e4lterekord\"\n    elif quantile == 0:\n        threshold = ds[\"tas\"] >= ds[\"tas_base\"].min(\"year\")\n        text = \"Tage \u00fcber Minimum\"\n    elif quantile > 0:\n        threshold = ds[\"tas\"] >= ds[\"tas_base\"].quantile(quantile, \"year\")\n        text = \"Tage in w\u00e4rmsten {:.0f}\\%\".format((1-quantile) * 100)\n    else:\n        threshold = ds[\"tas\"] <= ds[\"tas_base\"].quantile(np.abs(quantile), \"year\")\n        text = \"Tage in k\u00e4ltesten {:.0f}\\%\".format(np.abs(quantile) * 100)\n\n    y_min = ds[\"tas_base\"].min()  # for line placement\n    if np.any(threshold) or always:\n        threshold = (threshold.where(threshold) * 0) + y_min\n        ax.axhline(y_min, color=\"k\", ls=\"--\", lw=0.5)\n        ax.text(\n            33,\n            y_min,\n            \"{}: {}/{} ({:.0f}\\%)\".format(\n                text,\n                np.isfinite(threshold).sum().values,\n                np.isfinite(ds[\"tas\"]).sum().values,\n                np.isfinite(threshold).sum().values / np.isfinite(ds[\"tas\"]).sum().values * 100\n            ),\n            va=\"bottom\",\n        )\n        ax.plot(ds[\"dayofyear\"], threshold, marker=\"s\", ms=2, ls=\"none\", color=\"darkred\")\n        ds.attrs[\"show_record\"] = \"True\"\n\n\ndef annotate_last_day(ax: plt.Axes, ds: xr.Dataset) -> None:\n    \"\"\"Plot the anomaly and rank of the last available day of year.\"\"\"\n    year = ds.attrs[\"year\"]\n    doy_last = ds.attrs[\"last_doy\"]\n    ds_last = ds.sel(dayofyear=doy_last, drop=True)\n    middle = ds_last[\"tas_base\"].median(\"year\").values  # TODO: add mean\n\n    rank_last = ds_last[\"rank\"].sel(year=year).values\n    rank_total = ds_last[\"year\"].size\n    anom_last = (ds_last[\"tas\"] - middle).values\n\n    # print(middle)\n\n    text = f\"{anom_last:+.1f}$^\\\\circ$C\\n{rank_last}/{rank_total}\"\n\n    if doy_last > 321:  # adjust possition to avoid running out the plot\n        x_pos = 360\n        min_ = np.nanmin(ds[\"tas\"].isel(dayofyear=ds[\"dayofyear\"] > 321))\n        ylim1, ylim2 = ax.get_ylim()\n        y_pos = np.min([min_, middle]) - 0.03 * (ylim2 - ylim1)\n        ha = \"right\"\n        va = \"top\"\n    else:\n        x_pos = doy_last + 5\n        y_pos = middle + 0.5 * anom_last\n        ha = \"left\"\n        va = \"center\"\n\n    ax.vlines(doy_last, ds_last[\"tas\"], middle, colors=\"darkred\", ls=\":\", lw=1)\n    ax.text(\n        x_pos,\n        y_pos,\n        text,\n        color=\"darkred\",\n        ha=ha,\n        va=va,\n        multialignment=\"left\",\n        bbox=dict(facecolor=\"w\", alpha=0.4, edgecolor=\"none\"),\n    )\n\n\ndef annotate_shading(ax: plt.Axes, da: xr.DataArray, german: bool) -> None:\n    \"\"\"Add an explainer about the meaning of the shading.\n\n    Parameters\n    ----------\n    ax : plt.Axes\n    da : xr.DataArray\n    \"\"\"\n    if german:\n        # # upper percentile\n        # doy = 90  # target possition\n        # y_pos = da.sel(dayofyear=doy).quantile(.98, 'year')\n        # ax.annotate(\n        #     '10\\\\,\\\\% w\u00e4rmste Jahre',\n        #     (doy, y_pos),\n        #     (30, da.sel(dayofyear=doy + 30).max().values),\n        #     verticalalignment='center',\n        #     arrowprops={'arrowstyle': '->'}, fontsize='small',\n        # )\n\n        # lower percentile\n        doy = 120\n        y_pos = da.sel(dayofyear=doy).quantile(0.02, \"year\").values\n        ax.annotate(\n            \"10\\\\,\\\\% k\u00e4lteste Jahre\",\n            (doy, y_pos),\n            (150, da.sel(dayofyear=doy).min().values),\n            verticalalignment=\"center\",\n            horizontalalignment=\"left\",\n            arrowprops={\"arrowstyle\": \"->\", \"relpos\": (0.5, 0.5)},\n            fontsize=\"small\",\n        )\n    else:\n        # lower percentile\n        doy = 120\n        y_pos = da.sel(dayofyear=doy).quantile(0.02, \"year\").values\n        ax.annotate(\n            \"10\\\\,\\\\% coldest years\",\n            (doy, y_pos),\n            (150, da.sel(dayofyear=doy).min().values),\n            verticalalignment=\"center\",\n            horizontalalignment=\"left\",\n            arrowprops={\"arrowstyle\": \"->\", \"relpos\": (0.5, 0.5)},\n            fontsize=\"small\",\n        )\n\n\ndef plot_ccby(ax: plt.Axes, ds: xr.Dataset, twitter_handle: bool = True,) -> None:\n    \"\"\"Add a license to the plot.\n\n    Parameters\n    ----------\n    ax : plt.Axes\n    twitter_handle : bool, optional\n        Whether to also add the Twitter handle, by default True\n    loc : str, optional\n        Location of the license, by default 'lower right'\n    \"\"\"\n    if bool(ds.attrs.get(\"cummean\", False)):\n        if bool(ds.attrs.get(\"show_record\", False)):\n            yy = 0.05\n        else:\n            yy = 0.01\n    else:\n        # TODO: update placement\n        yy = 0.86\n\n    arr = mpimg.imread(os.path.join(current_path, \"../../images/by.png\"))\n    imagebox = OffsetImage(arr, zoom=0.19)\n    ab = AnnotationBbox(\n        imagebox,\n        (0.99, yy + 0.06),\n        frameon=False,\n        box_alignment=(1, 0),\n        xycoords=\"axes fraction\",\n    )\n    ax.add_artist(ab)\n    ax.annotate(\n        \"Lukas Brunner\",\n        (0, 0),\n        xytext=(0.99, yy + 0.03),\n        fontsize=\"xx-small\",\n        ha=\"right\",\n        va=\"bottom\",\n        xycoords=\"axes fraction\",\n    )\n    if twitter_handle:\n        ax.annotate(\n            \"@luki_brunner\",\n            (0, 0),\n            xytext=(0.99, yy),\n            fontsize=\"xx-small\",\n            color=\"blue\",\n            ha=\"right\",\n            va=\"bottom\",\n            xycoords=\"axes fraction\",\n        )\n\n\ndef plot_legend(ax: plt.Axes, handles: list, ds: xr.Dataset):\n    year_start = ds[\"year\"][0].values\n    # last not nan year in base\n    year_end = ds[\"year\"][np.isfinite(ds[\"tas_base\"].sel(dayofyear=1, drop=True))][\n        -1\n    ].values\n    years = \"{}-{}\".format(year_start, year_end)\n    ax.legend(handles, [years, ds.attrs[\"year\"]], loc=\"upper left\")\n\n\ndef plot_main(\n    ds: xr.Dataset,\n    ax: plt.Axes = None,\n    dpi_ratio: float = 1.2,\n    language: str = \"german\",\n    show_exceedance: float = 1.1,\n):\n    \"\"\"Main plotting function. Calls relevant subfunctions.\"\"\"\n    if ax is None:\n        fig, ax = plt.subplots(\n            figsize=(16 / dpi_ratio, 9 / dpi_ratio), dpi=150 * dpi_ratio\n        )\n    h1 = plot_base(ax, ds, german=language == \"german\")\n    # show_record = True if bool(ds.attrs.get('cummean', False)) else 'always'\n    # show_record = True\n    h2 = plot_target(ax, ds, show_exceedance=show_exceedance)\n    plot_legend(ax, [h1, h2], ds)\n    plot_ccby(ax, ds)\n    plt.gcf().tight_layout()\n", "type": "text"}, {"name": "core/plot_functions.py~", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\n(c) by Lukas Brunner under a MIT License (https://mit-license.org)\n\nAuthors:\n- Lukas Brunner || lukas.brunner@env.ethz.ch\n\nAbstract: A collection of plotting functions.\n\"\"\"\nimport os\nfrom datetime import datetime\nfrom typing import List, Tuple\n\nimport matplotlib.image as mpimg\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport xarray as xr\nfrom matplotlib.offsetbox import AnnotationBbox, OffsetImage\n\nmap_names = {\n    \"global\": \"Global\",\n    \"global-land\": \"Global (Land)\",\n    \"europe-land\": \"in Europa (Land)\",\n    \"europe\": \"in Europa\",\n    \"wce-land\": \"in Zentraleuropa\",\n    \"austria\": \"in \u00d6sterreich\",\n}\n\nmap_names_en = {\n    \"global\": \"global\",\n    \"global-land\": \"global (land)\",\n    \"europe-land\": \"in Europe (land)\",\n    \"europe\": \"in Europe\",\n    \"wce-land\": \"in Central Europe\",\n    \"austria\": \"in Austria\",\n}\n\ncurrent_path = os.path.dirname(os.path.abspath(__file__))\n\n\ndef plot_base(\n    ax: plt.Axes,\n    ds: xr.DataArray,\n    mean: bool = False,\n    median: bool = True,\n    q_ranges: List[Tuple[float, float]] = [\n        (0.0, 1.0),\n        (0.1, 0.9),\n        (0.2, 0.8),\n        (0.3, 0.7),\n        (0.4, 0.6),\n    ],\n    record: bool = True,\n    german: bool = True,\n    annotate: bool = True,\n) -> tuple:\n    \"\"\"Plot background shading and basic axis.\"\"\"\n    if mean and median:\n        raise ValueError('Only one of \"median\" and \"mean\" can be True')\n\n    cummean = bool(ds.attrs.get(\"cummean\", False))\n    year = ds.attrs[\"year\"]\n    region = ds.attrs[\"region\"]\n    last_doy = ds.attrs[\"last_doy\"]\n    doys = ds[\"dayofyear\"].values\n\n    for q1, q2 in q_ranges:\n        hh = ax.fill_between(\n            doys,\n            ds[\"tas_base\"].quantile(q1, \"year\"),\n            ds[\"tas_base\"].quantile(q2, \"year\"),\n            facecolor=\"k\",\n            edgecolor=\"none\",\n            alpha=0.1,\n        )\n\n    if mean:\n        [h2] = ax.plot(doys, ds[\"tas_base\"].mean(\"year\"), color=\"k\", lw=0.5)\n        hh = (hh, h2)\n    if median:\n        [h2] = ax.plot(doys, ds[\"tas_base\"].median(\"year\"), color=\"k\", lw=0.5)\n        hh = (hh, h2)\n\n    ax.set_xlim(doys[0], doys[-1])\n    ax.set_xticks([1, 60, 121, 182, 243, 304, 365])\n    ax.set_yticks(ax.get_yticks())\n    ax.set_yticklabels(\n        [int(ll) if float(ll).is_integer() else ll for ll in ax.get_yticks()]\n    )\n    ax.yaxis.set_ticks_position(\"both\")\n    if german:\n        ax.set_ylabel(\"Temperatur ($^\\\\circ$C)\")\n        ax.set_xticklabels(\n            [\"1. J\u00e4n.\", \"1. M\u00e4rz\", \"1. Mai\", \"1. Jul.\", \"1. Sep\", \"1. Nov.\", \"31. Dez.\"]\n        )\n        if year is not None and last_doy is not None and region is not None:\n            date = datetime.strptime(f\"{year}-{last_doy}\", \"%Y-%j\").strftime(\"%d.%m.%Y\")\n            if cummean:\n                ax.set_title(\n                    \"Kumulative Mitteltemperatur {} bis {}\".format(\n                        map_names[region], date\n                    )\n                )\n            else:\n                ax.set_title(\n                    \"Tagesmitteltemperatur {} bis {}\".format(map_names[region], date)\n                )\n        if cummean:\n            ax.text(\n                0.99,\n                0.4,\n                \"\\n\".join(\n                    [\n                        \"\\\\textbf{Kumulative Mitteltemperatur}\",\n                        \"Mittlere Temperatur vom 1. J\u00e4nnner\",\n                        \"bis zum angegebenen Tag\",\n                    ]\n                ),\n                ha=\"right\",\n                va=\"top\",\n                fontsize=\"small\",\n                transform=ax.transAxes,\n            )\n    else:\n        ax.set_ylabel(\"Temperature ($^\\\\circ$C)\")\n        ax.set_xticklabels(\n            [\"1. Jan.\", \"1. Mar.\", \"1. May\", \"1. Jul.\", \"1. Sep\", \"1. Nov.\", \"31. Dec.\"]\n        )\n        if year is not None and last_doy is not None and region is not None:\n            date = datetime.strptime(f\"{year}-{last_doy}\", \"%Y-%j\").strftime(\"%d.%m.%Y\")\n            if cummean:\n                ax.set_title(\n                    \"Cumulative mean temperature {} to {}\".format(\n                        map_names_en[region], date\n                    )\n                )\n            else:\n                ax.set_title(\n                    \"Daily mean temperature {} to {}\".format(map_names_en[region], date)\n                )\n        if cummean:\n            ax.text(\n                0.99,\n                0.4,\n                \"\\n\".join(\n                    [\n                        \"\\\\textbf{Cumulative mean temperature}\",\n                        \"Mean temperature from January 1$^\\\\textnormal{st}$\",\n                        \"until the indicated day\",\n                    ]\n                ),\n                ha=\"right\",\n                va=\"top\",\n                fontsize=\"small\",\n                transform=ax.transAxes,\n            )\n    if annotate:\n        annotate_shading(ax, ds[\"tas_base\"], german)\n\n    return hh\n\n\ndef plot_target(\n    ax: plt.Axes,\n    ds: xr.Dataset,\n    show_record: Tuple[bool, str] = \"always\",\n    show_exceedance: float = 1.,\n    show_rank: bool = True,\n) -> \"handle\":\n    \"\"\"Plot the target year and related information.\n\n    Parameters\n    ----------\n    ax : plt.Axes\n    ds : xr.Dataset\n    show_record : bool or 'always', optional, by default 'always'\n        If False do not show days with a new record. If True only show the\n        indicator if there is at least one day with a record. If 'always'\n        always show it. TODO: remove - redundant with 'show_exceedance'\n    show_exceedance : float, optional, by default 1.\n        Several cases are disdinguished:\n          - if absolute value larger than 1 do not show days with exceedances or new records\n          - if exactly 1 show new heat records (default)\n          - if exactly -1 show new cold records\n          - if positive show exceedances of the given quantile\n          - if negative show undercuts of given (absolut value) of quantile\n    show_rank : bool, optional, by default True\n        Annotate the last day with rank and anomaly.\n\n    Returns\n    -------\n    handle\n        For use in the figure legend.\n    \"\"\"\n    [h2] = ax.plot(ds[\"dayofyear\"], ds[\"tas\"], color=\"darkred\")\n    # if show_record is not None:\n    #     mark_record(ax, ds, show_record == \"always\")\n    if np.abs(show_exceedance) <= 1:\n            mark_exceedance(ax, ds, show_exceedance)\n    if show_rank:\n        annotate_last_day(ax, ds)\n    return h2\n\n\ndef mark_record(ax: plt.Axes, ds: xr.Dataset, always: bool = False) -> None:\n    \"\"\"Indicate days where the year has the maximum value.\"\"\"\n    max_ = ds[\"tas\"] >= ds[\"tas_base\"].max(\"year\")\n    # min_ = ds[\"tas\"] <= ds[\"tas_base\"].min(\"year\")\n    # record = np.logical_or(max_, min_)\n    y_min = ds[\"tas_base\"].min()  # for line placement\n    if np.any(max_) or always:\n        max_ = (max_.where(max_) * 0) + y_min\n        ax.axhline(y_min, color=\"k\", ls=\"--\", lw=0.5)\n        ax.text(\n            33,\n            y_min,\n            \"Tage mit Hitzerekord: {}/{}\".format(\n                np.isfinite(max_).sum().values, np.isfinite(ds[\"tas\"]).sum().values\n            ),\n            va=\"bottom\",\n        )\n        ax.plot(ds[\"dayofyear\"], max_, marker=\"s\", ms=2, ls=\"none\", color=\"darkred\")\n        ds.attrs[\"show_record\"] = \"True\"\n\n\ndef mark_exceedance(ax: plt.Axes, ds: xr.Dataset, quantile: float, always: bool = True) -> None:\n    \"\"\"Indicate days where the year exceeds a given percentile.\"\"\"\n    if quantile == 1:\n        threshold = ds[\"tas\"] >= ds[\"tas_base\"].max(\"year\")\n        text = \"Tage mit Hitzerekord\"\n    elif quantile == -1:\n        threshold = ds[\"tas\"] <= ds[\"tas_base\"].min(\"year\")\n        text = \"Tage mit K\u00e4lterekord\"\n    elif quantile == 0:\n        threshold = ds[\"tas\"] >= ds[\"tas_base\"].min(\"year\")\n        text = \"Tage \u00fcber Minimum\"\n    elif quantile > 0:\n        threshold = ds[\"tas\"] >= ds[\"tas_base\"].quantile(quantile, \"year\")\n        text = \"Tage in w\u00e4rmsten {:.0f}\\%\".format(quantile * 100)\n    else:\n        threshold = ds[\"tas\"] <= ds[\"tas_base\"].quantile(quantile, \"year\")\n        text = \"Tage in k\u00e4ltesten {:.0f}\\%\".format(quantile * 100)\n\n    y_min = ds[\"tas_base\"].min()  # for line placement\n    if np.any(threshold) or always:\n        threshold = (threshold.where(threshold) * 0) + y_min\n        ax.axhline(y_min, color=\"k\", ls=\"--\", lw=0.5)\n        ax.text(\n            33,\n            y_min,\n            \"{}: {}/{} ({:.0f}\\%)\".format(\n                text,\n                np.isfinite(threshold).sum().values,\n                np.isfinite(ds[\"tas\"]).sum().values,\n                np.isfinite(threshold).sum().values / np.isfinite(ds[\"tas\"]).sum().values * 100\n            ),\n            va=\"bottom\",\n        )\n        ax.plot(ds[\"dayofyear\"], threshold, marker=\"s\", ms=2, ls=\"none\", color=\"darkred\")\n        ds.attrs[\"show_record\"] = \"True\"\n\n\ndef annotate_last_day(ax: plt.Axes, ds: xr.Dataset) -> None:\n    \"\"\"Plot the anomaly and rank of the last available day of year.\"\"\"\n    year = ds.attrs[\"year\"]\n    doy_last = ds.attrs[\"last_doy\"]\n    ds_last = ds.sel(dayofyear=doy_last, drop=True)\n    middle = ds_last[\"tas_base\"].median(\"year\").values  # TODO: add mean\n\n    rank_last = ds_last[\"rank\"].sel(year=year).values\n    rank_total = ds_last[\"year\"].size\n    anom_last = (ds_last[\"tas\"] - middle).values\n\n    # print(middle)\n\n    text = f\"{anom_last:+.1f}$^\\\\circ$C\\n{rank_last}/{rank_total}\"\n\n    if doy_last > 321:  # adjust possition to avoid running out the plot\n        x_pos = 360\n        min_ = np.nanmin(ds[\"tas\"].isel(dayofyear=ds[\"dayofyear\"] > 321))\n        ylim1, ylim2 = ax.get_ylim()\n        y_pos = np.min([min_, middle]) - 0.03 * (ylim2 - ylim1)\n        ha = \"right\"\n        va = \"top\"\n    else:\n        x_pos = doy_last + 5\n        y_pos = middle + 0.5 * anom_last\n        ha = \"left\"\n        va = \"center\"\n\n    ax.vlines(doy_last, ds_last[\"tas\"], middle, colors=\"darkred\", ls=\":\", lw=1)\n    ax.text(\n        x_pos,\n        y_pos,\n        text,\n        color=\"darkred\",\n        ha=ha,\n        va=va,\n        multialignment=\"left\",\n        bbox=dict(facecolor=\"w\", alpha=0.4, edgecolor=\"none\"),\n    )\n\n\ndef annotate_shading(ax: plt.Axes, da: xr.DataArray, german: bool) -> None:\n    \"\"\"Add an explainer about the meaning of the shading.\n\n    Parameters\n    ----------\n    ax : plt.Axes\n    da : xr.DataArray\n    \"\"\"\n    if german:\n        # # upper percentile\n        # doy = 90  # target possition\n        # y_pos = da.sel(dayofyear=doy).quantile(.98, 'year')\n        # ax.annotate(\n        #     '10\\\\,\\\\% w\u00e4rmste Jahre',\n        #     (doy, y_pos),\n        #     (30, da.sel(dayofyear=doy + 30).max().values),\n        #     verticalalignment='center',\n        #     arrowprops={'arrowstyle': '->'}, fontsize='small',\n        # )\n\n        # lower percentile\n        doy = 120\n        y_pos = da.sel(dayofyear=doy).quantile(0.02, \"year\").values\n        ax.annotate(\n            \"10\\\\,\\\\% k\u00e4lteste Jahre\",\n            (doy, y_pos),\n            (150, da.sel(dayofyear=doy).min().values),\n            verticalalignment=\"center\",\n            horizontalalignment=\"left\",\n            arrowprops={\"arrowstyle\": \"->\", \"relpos\": (0.5, 0.5)},\n            fontsize=\"small\",\n        )\n    else:\n        # lower percentile\n        doy = 120\n        y_pos = da.sel(dayofyear=doy).quantile(0.02, \"year\").values\n        ax.annotate(\n            \"10\\\\,\\\\% coldest years\",\n            (doy, y_pos),\n            (150, da.sel(dayofyear=doy).min().values),\n            verticalalignment=\"center\",\n            horizontalalignment=\"left\",\n            arrowprops={\"arrowstyle\": \"->\", \"relpos\": (0.5, 0.5)},\n            fontsize=\"small\",\n        )\n\n\ndef plot_ccby(ax: plt.Axes, ds: xr.Dataset, twitter_handle: bool = True,) -> None:\n    \"\"\"Add a license to the plot.\n\n    Parameters\n    ----------\n    ax : plt.Axes\n    twitter_handle : bool, optional\n        Whether to also add the Twitter handle, by default True\n    loc : str, optional\n        Location of the license, by default 'lower right'\n    \"\"\"\n    if bool(ds.attrs.get(\"cummean\", False)):\n        if bool(ds.attrs.get(\"show_record\", False)):\n            yy = 0.05\n        else:\n            yy = 0.01\n    else:\n        # TODO: update placement\n        yy = 0.86\n\n    arr = mpimg.imread(os.path.join(current_path, \"../../images/by.png\"))\n    imagebox = OffsetImage(arr, zoom=0.19)\n    ab = AnnotationBbox(\n        imagebox,\n        (0.99, yy + 0.06),\n        frameon=False,\n        box_alignment=(1, 0),\n        xycoords=\"axes fraction\",\n    )\n    ax.add_artist(ab)\n    ax.annotate(\n        \"Lukas Brunner\",\n        (0, 0),\n        xytext=(0.99, yy + 0.03),\n        fontsize=\"xx-small\",\n        ha=\"right\",\n        va=\"bottom\",\n        xycoords=\"axes fraction\",\n    )\n    if twitter_handle:\n        ax.annotate(\n            \"@luki_brunner\",\n            (0, 0),\n            xytext=(0.99, yy),\n            fontsize=\"xx-small\",\n            color=\"blue\",\n            ha=\"right\",\n            va=\"bottom\",\n            xycoords=\"axes fraction\",\n        )\n\n\ndef plot_legend(ax: plt.Axes, handles: list, ds: xr.Dataset):\n    year_start = ds[\"year\"][0].values\n    # last not nan year in base\n    year_end = ds[\"year\"][np.isfinite(ds[\"tas_base\"].sel(dayofyear=1, drop=True))][\n        -1\n    ].values\n    years = \"{}-{}\".format(year_start, year_end)\n    ax.legend(handles, [years, ds.attrs[\"year\"]], loc=\"upper left\")\n\n\ndef plot_main(\n    ds: xr.Dataset,\n    ax: plt.Axes = None,\n    dpi_ratio: float = 1.2,\n    language: str = \"german\",\n    show_exceedance: float = 1.1,\n):\n    \"\"\"Main plotting function. Calls relevant subfunctions.\"\"\"\n    if ax is None:\n        fig, ax = plt.subplots(\n            figsize=(16 / dpi_ratio, 9 / dpi_ratio), dpi=150 * dpi_ratio\n        )\n    h1 = plot_base(ax, ds, german=language == \"german\")\n    # show_record = True if bool(ds.attrs.get('cummean', False)) else 'always'\n    # show_record = True\n    h2 = plot_target(ax, ds, show_exceedance=show_exceedance)\n    plot_legend(ax, [h1, h2], ds)\n    plot_ccby(ax, ds)\n    plt.gcf().tight_layout()\n", "type": "text"}, {"name": "core/utilities.py", "content": "import warnings\n\nimport dask\nimport numpy as np\n# import regionmask\nimport xarray as xr\n\nregions = {\n    \"global\": {\"region\": \"global\"},\n    \"global-land\": {\"region\": \"global\", \"land_sea\": \"land\"},\n    # \"europe-land\": {\"region\": \"EUR\", \"land_sea\": \"land\"},\n    \"europe\": {\"region\": \"EUR\"},\n    \"wce-land\": {\"region\": \"WCE\", \"land_sea\": \"land\"},\n    \"austria\": {\"region\": \"Austria\"},\n}\n\n\ndef area_weighted_mean(ds: \"xr.dataset\", latn=\"lat\", lonn=\"lon\") -> \"xr.dataset\":\n    \"\"\"Calculate area mean weighted by the latitude.\"\"\"\n    weights_lat = np.cos(np.radians(ds[latn]))\n    return ds.weighted(weights_lat).mean((latn, lonn))\n\n\ndef set_antimeridian(\n    dataarray: \"xr.DataArray\", to: str = \"pacific\", lonn: str = \"lon\"\n) -> \"xr.DataArray\":\n    \"\"\"\n    Flip the antimeridian (i.e. longitude discontinuity) between Europe\n    (i.e., [0, 360)) and the Pacific (i.e., [-180, 180)).\n\n    Parameters:\n    - dataarray : xarray.DataArray\n    - to : string, {'Pacific', 'Europe'}\n      * 'Europe': Longitude will be in [0, 360)\n      * 'Pacific': Longitude will be in [-180, 180)\n    - lonn: string, optional\n\n    Returns:\n    dataarray_flipped : xarray.DataArray\n    \"\"\"\n    lon = dataarray[lonn]\n    lon_attrs = lon.attrs\n\n    if to.lower() == \"europe\":\n        dataarray = dataarray.assign_coords(**{lonn: (lon % 360)})\n    elif to.lower() == \"pacific\":\n        dataarray = dataarray.assign_coords(**{lonn: (((lon + 180) % 360) - 180)})\n    else:\n        errmsg = \"to has to be one of ['Europe', 'Pacific'] not {}\".format(to)\n        raise ValueError(errmsg)\n\n    idx = np.argmin(dataarray[lonn].values)\n    dataarray = dataarray.roll(**{lonn: -idx}, roll_coords=True)\n    dataarray[lonn].attrs = lon_attrs\n    return dataarray\n\n\n# def make_regions() -> regionmask:\n#     \"\"\"Create manually defined regions.\"\"\"\n#     europe = np.array([[-10.0, 76.25], [39.0, 76.25], [39.0, 30.0], [-10.0, 30.0]])\n#     return regionmask.Regions([europe], names=[\"Europe\"], abbrevs=[\"EUR\"])\n\n\ndef cut_region(\n    dataset: \"xr.Dataset\",  # TODO: currently I would want to pass a ds!\n    region: str,\n    land_sea: str = \"both\",\n) -> \"xr.Dataset\":\n    \"\"\"\n    Parameters\n    ----------\n    data_array : xarray.DataArray\n    region : string, optional\n        Either one IPCC AR6 regions\n        (https://regionmask.readthedocs.io/en/stable/defined_scientific.html)\n        or a country\n    land_sea : string, optional, on of {'land', 'sea', 'both'}\n\n    Returns\n    -------\n    data_array : xarray.DataArray\n        A data_array with grid cells outside of the given area set to nan\n        and longitudes and latitudes with only nan values dropped.\n\n    Raises\n    ------\n    ValueError\n        All values are masked.\n    \"\"\"\n    # dataset = set_antimeridian(dataset)\n    da = dataset\n\n    if region.lower() == \"global\" and land_sea == \"both\":\n        return dataset, None\n\n    if region.lower() == \"global\":\n        mask = True\n    elif region in regionmask.defined_regions.ar6.all.abbrevs:\n        key = regionmask.defined_regions.ar6.all.map_keys(region)\n        mask = regionmask.defined_regions.ar6.all.mask(da, wrap_lon=None) == key\n    elif region in regionmask.defined_regions.natural_earth.countries_110.names:\n        key = regionmask.defined_regions.natural_earth.countries_110.map_keys(region)\n        mask = (\n            regionmask.defined_regions.natural_earth.countries_110.mask(\n                da, wrap_lon=None\n            )\n            == key\n        )\n    else:\n        try:\n            manual_regions = make_regions()\n            key = manual_regions.map_keys(region)\n            mask = manual_regions.mask(da, wrap_lon=None) == key\n        except KeyError:\n            raise IOError(f\"Invalid region {region}\")\n\n    if land_sea == \"land\":\n        land = (\n            regionmask.defined_regions.natural_earth.land_110.mask(da, wrap_lon=None)\n            == 0\n        )\n        mask &= land\n    elif land_sea == \"sea\":\n        land = (\n            regionmask.defined_regions.natural_earth.land_110.mask(da, wrap_lon=None)\n            == 0\n        )\n        mask &= ~land\n    elif land_sea != \"both\":\n        raise IOError(\"Invalid land-sea mask string\")\n\n    if not np.any(mask):\n        raise ValueError(\"all values masked\")\n\n    return dataset.where(mask, drop=True), mask.where(mask, drop=True)\n\n\ndef average_region(da: xr.DataArray, region: str) -> xr.DataArray:\n    with dask.config.set(**{\"array.slicing.split_large_chunks\": False}):\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            da, _ = cut_region(da, **regions[region])\n    da = area_weighted_mean(da)\n    return da\n\n\ndef kelvin_to_centigrade(da: xr.DataArray) -> xr.DataArray:\n    da = da - 273.15\n    da.attrs[\"units\"] = \"degree_C\"\n    return da\n\n\ndef delete_last_day_leap_year(da: xr.DataArray) -> xr.DataArray:\n    return da.where(da[\"dayofyear\"] != 366, drop=True)\n\n\ndef time_to_dayofyear(da: xr.DataArray, delete_leap_year: bool = True) -> xr.DataArray:\n    da = da.assign_coords(time=da[\"time.dayofyear\"])\n    da = da.rename({\"time\": \"dayofyear\"})\n    if delete_leap_year:\n        da = delete_last_day_leap_year(da)\n    return da\n", "type": "text"}, {"name": "core/utilities.py~", "content": "import warnings\n\nimport dask\nimport numpy as np\nimport regionmask\nimport xarray as xr\n\nregions = {\n    \"global\": {\"region\": \"global\"},\n    \"global-land\": {\"region\": \"global\", \"land_sea\": \"land\"},\n    \"europe-land\": {\"region\": \"EUR\", \"land_sea\": \"land\"},\n    \"europe\": {\"region\": \"EUR\"},\n    \"wce-land\": {\"region\": \"WCE\", \"land_sea\": \"land\"},\n    \"austria\": {\"region\": \"Austria\"},\n}\n\n\ndef area_weighted_mean(ds: \"xr.dataset\", latn=\"lat\", lonn=\"lon\") -> \"xr.dataset\":\n    \"\"\"Calculate area mean weighted by the latitude.\"\"\"\n    weights_lat = np.cos(np.radians(ds[latn]))\n    return ds.weighted(weights_lat).mean((latn, lonn))\n\n\ndef set_antimeridian(\n    dataarray: \"xr.DataArray\", to: str = \"pacific\", lonn: str = \"lon\"\n) -> \"xr.DataArray\":\n    \"\"\"\n    Flip the antimeridian (i.e. longitude discontinuity) between Europe\n    (i.e., [0, 360)) and the Pacific (i.e., [-180, 180)).\n\n    Parameters:\n    - dataarray : xarray.DataArray\n    - to : string, {'Pacific', 'Europe'}\n      * 'Europe': Longitude will be in [0, 360)\n      * 'Pacific': Longitude will be in [-180, 180)\n    - lonn: string, optional\n\n    Returns:\n    dataarray_flipped : xarray.DataArray\n    \"\"\"\n    lon = dataarray[lonn]\n    lon_attrs = lon.attrs\n\n    if to.lower() == \"europe\":\n        dataarray = dataarray.assign_coords(**{lonn: (lon % 360)})\n    elif to.lower() == \"pacific\":\n        dataarray = dataarray.assign_coords(**{lonn: (((lon + 180) % 360) - 180)})\n    else:\n        errmsg = \"to has to be one of ['Europe', 'Pacific'] not {}\".format(to)\n        raise ValueError(errmsg)\n\n    idx = np.argmin(dataarray[lonn].values)\n    dataarray = dataarray.roll(**{lonn: -idx}, roll_coords=True)\n    dataarray[lonn].attrs = lon_attrs\n    return dataarray\n\n\ndef make_regions() -> regionmask:\n    \"\"\"Create manually defined regions.\"\"\"\n    europe = np.array([[-10.0, 76.25], [39.0, 76.25], [39.0, 30.0], [-10.0, 30.0]])\n    return regionmask.Regions([europe], names=[\"Europe\"], abbrevs=[\"EUR\"])\n\n\ndef cut_region(\n    dataset: \"xr.Dataset\",  # TODO: currently I would want to pass a ds!\n    region: str,\n    land_sea: str = \"both\",\n) -> \"xr.Dataset\":\n    \"\"\"\n    Parameters\n    ----------\n    data_array : xarray.DataArray\n    region : string, optional\n        Either one IPCC AR6 regions\n        (https://regionmask.readthedocs.io/en/stable/defined_scientific.html)\n        or a country\n    land_sea : string, optional, on of {'land', 'sea', 'both'}\n\n    Returns\n    -------\n    data_array : xarray.DataArray\n        A data_array with grid cells outside of the given area set to nan\n        and longitudes and latitudes with only nan values dropped.\n\n    Raises\n    ------\n    ValueError\n        All values are masked.\n    \"\"\"\n    # dataset = set_antimeridian(dataset)\n    da = dataset\n\n    if region.lower() == \"global\" and land_sea == \"both\":\n        return dataset, None\n\n    if region.lower() == \"global\":\n        mask = True\n    elif region in regionmask.defined_regions.ar6.all.abbrevs:\n        key = regionmask.defined_regions.ar6.all.map_keys(region)\n        mask = regionmask.defined_regions.ar6.all.mask(da, wrap_lon=None) == key\n    elif region in regionmask.defined_regions.natural_earth.countries_110.names:\n        key = regionmask.defined_regions.natural_earth.countries_110.map_keys(region)\n        mask = (\n            regionmask.defined_regions.natural_earth.countries_110.mask(\n                da, wrap_lon=None\n            )\n            == key\n        )\n    else:\n        try:\n            manual_regions = make_regions()\n            key = manual_regions.map_keys(region)\n            mask = manual_regions.mask(da, wrap_lon=None) == key\n        except KeyError:\n            raise IOError(f\"Invalid region {region}\")\n\n    if land_sea == \"land\":\n        land = (\n            regionmask.defined_regions.natural_earth.land_110.mask(da, wrap_lon=None)\n            == 0\n        )\n        mask &= land\n    elif land_sea == \"sea\":\n        land = (\n            regionmask.defined_regions.natural_earth.land_110.mask(da, wrap_lon=None)\n            == 0\n        )\n        mask &= ~land\n    elif land_sea != \"both\":\n        raise IOError(\"Invalid land-sea mask string\")\n\n    if not np.any(mask):\n        raise ValueError(\"all values masked\")\n\n    return dataset.where(mask, drop=True), mask.where(mask, drop=True)\n\n\ndef average_region(da: xr.DataArray, region: str) -> xr.DataArray:\n    with dask.config.set(**{\"array.slicing.split_large_chunks\": False}):\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            da, _ = cut_region(da, **regions[region])\n    da = area_weighted_mean(da)\n    return da\n\n\ndef kelvin_to_centigrade(da: xr.DataArray) -> xr.DataArray:\n    da = da - 273.15\n    da.attrs[\"units\"] = \"degree_C\"\n    return da\n\n\ndef delete_last_day_leap_year(da: xr.DataArray) -> xr.DataArray:\n    return da.where(da[\"dayofyear\"] != 366, drop=True)\n\n\ndef time_to_dayofyear(da: xr.DataArray, delete_leap_year: bool = True) -> xr.DataArray:\n    da = da.assign_coords(time=da[\"time.dayofyear\"])\n    da = da.rename({\"time\": \"dayofyear\"})\n    if delete_leap_year:\n        da = delete_last_day_leap_year(da)\n    return da\n", "type": "text"}]